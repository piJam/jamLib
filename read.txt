1、C++ 中临时变量不能作为，非const的引用参数
在Array中，virtual bool set(int i, T& t) 中T 没有加 const，导致在LinkGraph 中使用 DynamicArray 不能直接用临时变量赋值，后改为virtual bool set(int i, const T& t)

2、关于链表
   2.1、链表头节点为什么不直接用Node结构体？
   理解：头节点结构体用char 数组代替 Node 中 value，目的提高效率，如果链表中存储对象，在初始化时需要调用构造函数，系统效率会降低。
   2.2、如果链表存储对象，则对象的类必须提供无参构造函数或有默认值的构造函数
   理解：在链表Node中，Node初始化默认调用无参构造函数，value作为对象的，则也默认调用无参构造函数（不提供编译器会报错）。

3、关于队列 LinkQueue
     在出队遍历中，不能用 for(int i=0; i<quque.length();  i++) 循环，队列长度每次经过remove的时候，都在减小，用for，i最多只能遍历一半，循环就结束了,应该是 while( queue.lenght() > 0 )循环。





Prim算法理解：
1、从初始顶点找出其相关的邻接顶点；
2、将初始顶点到邻接顶点的权值（E）写进对应的cost数组位置（数组下标表示邻接顶点）
3、遍历cost数组找出权值最小的那个对应顶点（在第二次及以后循环加 判断是不是顶点已经到了t集合mark[]，在t集合中除外）
4、将最小权值顶点标记到t集合，并将对应的边加入到返回队列中。
5、再以这个最小值的顶点作为初始顶点，找出其他邻接顶点，并将对应的权值替换到cost数组中（条件：邻接顶点不在t集合，邻接顶点对应的权值比cost对应保存的值小，就替换）
6、进入3重复。
7、结束条件：5步中没有符合的条件，结束查找最小树。
8、判断返回队列元素的个数等于边的个数减1，不想等最小树不成立